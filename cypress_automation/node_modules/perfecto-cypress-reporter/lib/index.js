"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* global Cypress, cy */
var axios = require('axios');

var {
  REPORTING_TEST_STATUS,
  LAB_EXECUTION_REPORT_URL,
  MOCHA_STATUS,
  REPORTING_COMMAND_STATUS
} = require('./consts');

var commandHandler = require('./command-handler');

var ignoreReporterErrors = () => {
  /* do nothing this is not relevant to the execution */
};

var getFiledRecursively = function getFiledRecursively(field, data) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' - ';
  if (!data.parent) return data[field];
  var parentsValue = getFiledRecursively(field, data.parent, delimiter);
  return (parentsValue ? parentsValue + delimiter : '') + data[field];
};

var getSpecFile = () => Cypress.spec && Cypress.spec.relative;

var getCustomFields = () => {
  var customFields = [];
  var specFile = getSpecFile();

  if (specFile) {
    customFields.push({
      name: 'SpecFile',
      value: specFile
    });
  }

  if (Cypress.version) {
    customFields.push({
      name: 'CypressVersion',
      value: Cypress.version
    });
  }

  return customFields;
};

var isFailed = test => {
  return test.state === MOCHA_STATUS.FAILED;
};

Cypress.on('script:error', function (err) {
  return axios.post(LAB_EXECUTION_REPORT_URL + '/execution-data/', _objectSpread({}, err && err.error && {
    failedMsg: err.error
  }));
});
Cypress.on('test:before:run', function (_test, runner) {
  var testStartTime = new Date().getTime();
  var failedCommand; // TODO: (Elhay) second test not reported??
  // TODO: (Elhay) commands not reported??

  cy.on('test:after:run', test => {
    var isTestFailed = isFailed(test);
    var status = isTestFailed ? REPORTING_TEST_STATUS.FAILED : REPORTING_TEST_STATUS.PASSED;
    var message = isTestFailed ? test.err.stack : '';
    var testEndTime = new Date().getTime();
    return axios.post(LAB_EXECUTION_REPORT_URL + '/test-end/', {
      status,
      message,
      name: getFiledRecursively('title', runner),
      specFile: getSpecFile(),
      endTime: testEndTime,
      duration: testEndTime - testStartTime
    }).catch(ignoreReporterErrors);
  });
  cy.on('fail', error => {
    if (failedCommand) {
      axios.post(LAB_EXECUTION_REPORT_URL + '/command/', commandHandler.getCommandParams(failedCommand, REPORTING_COMMAND_STATUS.FAILURE)).catch(ignoreReporterErrors);
    }

    throw error;
  });
  cy.on('command:start', command => {
    command.startTime = new Date().getTime();
    failedCommand = command;
  });
  cy.on('command:end', command => {
    axios.post(LAB_EXECUTION_REPORT_URL + '/command/', commandHandler.getCommandParams(command)).catch(ignoreReporterErrors); // TODO: (Elhay) try  to report from here about failed command if  we have the status
  });
  return axios.post(LAB_EXECUTION_REPORT_URL + '/test-start', {
    name: getFiledRecursively('title', runner),
    startTime: testStartTime,
    specFile: getSpecFile(),
    context: {
      customFields: [...getCustomFields()]
    }
  }).catch(ignoreReporterErrors);
});