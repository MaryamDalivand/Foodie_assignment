"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TASKS = void 0;

var _listr = _interopRequireDefault(require("listr"));

var _logUpdate = _interopRequireDefault(require("log-update"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TASKS = {
  SESSION_INITIALIZE: 0,
  ALLOCATING_INSTANCES: 1,
  EXECUTION_INITIALIZE: 2,
  EXECUTING: 3,
  DONE: 4
};
exports.TASKS = TASKS;

var getTaskPromise = () => {
  var resolver;
  var promise = new Promise(resolve => {
    resolver = resolve;
  });
  return {
    resolver,
    promise
  };
};

var tasksResolvers = {
  tasks: {
    [TASKS.SESSION_INITIALIZE]: getTaskPromise(),
    [TASKS.ALLOCATING_INSTANCES]: getTaskPromise(),
    [TASKS.EXECUTION_INITIALIZE]: getTaskPromise(),
    [TASKS.EXECUTING]: getTaskPromise(),
    [TASKS.DONE]: getTaskPromise()
  },
  resolved: false,
  resolveAll: () => {
    Object.values(tasksResolvers.tasks).forEach(task => task.resolver());
    tasksResolvers.resolved = true;
  }
};
var initialisationTasks = new _listr.default([{
  title: 'Allocating devices',
  task: () => new _listr.default([{
    title: 'Calculating the desired amount of resources',
    task: () => tasksResolvers.tasks[TASKS.SESSION_INITIALIZE].promise
  }, {
    title: 'Connecting resources to this session',
    task: () => tasksResolvers.tasks[TASKS.ALLOCATING_INSTANCES].promise
  }])
}, {
  title: 'Preparing Cypress tests environment',
  task: () => new _listr.default([{
    title: 'Defined Node.js',
    task: () => tasksResolvers.tasks[TASKS.EXECUTION_INITIALIZE].promise
  }, {
    title: 'Selecting Browser',
    task: () => tasksResolvers.tasks[TASKS.EXECUTION_INITIALIZE].promise
  }])
}, {
  title: 'Installing project npm dependencies',
  task: () => new _listr.default([{
    title: 'Install Cypress version from package.json',
    task: () => tasksResolvers.tasks[TASKS.EXECUTION_INITIALIZE].promise
  }, {
    title: 'Installing other npm dependencies from package.json',
    task: () => tasksResolvers.tasks[TASKS.EXECUTION_INITIALIZE].promise
  }])
}], {
  collapse: false
});
var tasksLogger = {
  run: () => initialisationTasks.run(),
  endTask: taskId => {
    tasksResolvers.tasks[taskId].resolver();
    return new Promise(resolve => setTimeout(() => {
      resolve();
    }, 200));
  },
  endTasks: () => {
    if (tasksResolvers.resolved) {
      return Promise.resolve();
    }

    tasksResolvers.resolveAll(); // Wait for resolved tasks to be printed

    return new Promise(resolve => setTimeout(() => {
      _logUpdate.default.done();

      resolve();
    }, 200));
  },
  resolveAllTasks: () => {
    return tasksResolvers.resolved;
  }
};
var _default = tasksLogger;
exports.default = _default;