"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logHelpers = require("./log-helpers");

var _consts = require("../common/consts.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var sessionDataMap = new Map();
var specsMap = new Map();
var finalStatus = _consts.ResultState.PASSED;

var appendSpecsData = (executionId, platformHash, test) => {
  var specKey = executionId + '-' + test.specFile;
  var specData = specsMap.get(specKey);

  if (!specData) {
    specsMap.set(specKey, {
      platformHash,
      executionId,
      SPEC: test.specFile,
      Tests: 1,
      Status: test.status,
      Duration: test.duration,
      Passing: test.status === _consts.TestResults.PASSED ? 1 : 0,
      Failing: test.status !== _consts.TestResults.PASSED ? 1 : 0
    });
  } else {
    specData.Tests++;
    specData.Duration += test.duration;

    if (test.status === _consts.TestResults.PASSED) {
      specData.Passing++;
    } else {
      specData.Failing++;
      specData.Status = test.status;
    }
  }
};

var getBlockedExecutionData = () => {
  var blockedExecutions = [];
  sessionDataMap.forEach(sessionData => {
    var _sessionData$result;

    if (((_sessionData$result = sessionData.result) === null || _sessionData$result === void 0 ? void 0 : _sessionData$result.resultState) === "BLOCKED") {
      blockedExecutions.push({
        executionId: sessionData.executionId,
        platformHash: sessionData.platformHash,
        Status: "BLOCKED"
      });
    }
  });
  return blockedExecutions;
};

var sessionCloudName = '';
var sessionHolder = {
  getSessionData: () => [...sessionDataMap.values()],
  getSpecsSummary: () => [...specsMap.values()].sort((a, b) => a.platformHash - b.platformHash),
  getBlockedExecutionsSummary: () => [...getBlockedExecutionData()].sort((a, b) => a.platformHash - b.platformHash),
  getFinalStatus: () => finalStatus,
  getCloud: () => sessionCloudName,
  setCloud: cloudName => {
    sessionCloudName = cloudName;
  },
  appendSessionData: sessionData => {
    sessionData.executions.forEach(execution => {
      var platformHash = (0, _logHelpers.objectToHash)(execution.platform);

      if (!sessionDataMap.get(execution.executionId)) {
        sessionDataMap.set(execution.executionId, _objectSpread(_objectSpread({}, execution), {}, {
          platformHash: platformHash,
          isPrinted: false
        }));
      } else {
        var executionData = _objectSpread(_objectSpread({}, sessionDataMap.get(execution.executionId)), execution);

        sessionDataMap.set(execution.executionId, executionData);
      }

      if (execution.executionState === _consts.SessionState.DONE && sessionData && sessionData.resultState) {
        finalStatus = sessionData.resultState;
        sessionDataMap.get(execution.executionId).tests.forEach(test => appendSpecsData(execution.executionId, platformHash, test));
      }
    });
  }
};
var _default = sessionHolder;
exports.default = _default;