"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _axios = _interopRequireDefault(require("axios"));

var _api = require("../common/api");

var logHelpers = _interopRequireWildcard(require("./log-helpers"));

var _sessionData = _interopRequireDefault(require("./session-data"));

var _monitorLogger = _interopRequireDefault(require("./monitor-logger"));

var _tasksLogger = _interopRequireWildcard(require("./tasks-logger"));

var _consts = require("../common/consts");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var PULLING_INTERVAL = 3000;
var executionStartTime;
var sessionStatus;

var updateSessionStatus = isEnded => {
  if (sessionStatus === _consts.ExecutionState.EXECUTING || isEnded) {
    return _tasksLogger.default.endTasks();
  }

  var sessionData = _sessionData.default.getSessionData();

  var isExecuting = sessionData.find(execution => execution.executionState === _consts.ExecutionState.EXECUTING);

  if (isExecuting && sessionStatus === _consts.SessionState.INITIALIZING) {
    sessionStatus = _consts.ExecutionState.EXECUTING;
    return _tasksLogger.default.endTask(_tasksLogger.TASKS.EXECUTION_INITIALIZE);
  }

  var isInitializing = sessionData.find(execution => execution.executionState === _consts.ExecutionState.INITIALIZING);

  if (isInitializing && sessionStatus === _consts.ExecutionState.ALLOCATING) {
    sessionStatus = _consts.ExecutionState.INITIALIZING;
    return _tasksLogger.default.endTask(_tasksLogger.TASKS.ALLOCATING_INSTANCES);
  }

  var isAllocating = sessionData.find(execution => execution.executionState === _consts.ExecutionState.ALLOCATING);

  if (isAllocating && !sessionStatus) {
    sessionStatus = _consts.ExecutionState.ALLOCATING;
    return _tasksLogger.default.endTask(_tasksLogger.TASKS.SESSION_INITIALIZE);
  }

  return Promise.resolve();
};

var onExecutionEnd = (resolve, reject) => {
  var finalStatus = _sessionData.default.getFinalStatus();

  var durationText = logHelpers.printDuration(new Date().getTime() - executionStartTime);
  var message = "Session ended with status: ".concat(finalStatus, ".") + "".concat(_chalk.default.gray(durationText));

  if (finalStatus === _consts.ResultState.SUCCESS) {
    resolve(_chalk.default.green(message));
  } else {
    reject(_chalk.default.red(message));
  }
};

var getSessionDataLoop = (credentials, sessionId, resolve, reject) => {
  _axios.default.get((0, _api.getBackendBaseUrl)(credentials.cloud) + '/sessions/' + sessionId, {
    headers: (0, _api.getPerfectoHeaders)(credentials.cloud, credentials.securityToken)
  }).then( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (res) {
      var sessionData = res.data;

      if (sessionData.executions && sessionData.executions.length) {
        _sessionData.default.appendSessionData(sessionData);
      }

      yield updateSessionStatus(sessionData.sessionState === _consts.SessionState.DONE);

      _monitorLogger.default.logNewSessionData(sessionData);

      if (sessionData.sessionState !== _consts.SessionState.DONE) {
        setTimeout(() => getSessionDataLoop(credentials, sessionId, resolve, reject), PULLING_INTERVAL);
      } else {
        onExecutionEnd(resolve, reject);
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }()).catch(reject);
};

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (credentials, session) {
    _sessionData.default.setCloud(credentials.cloud);

    _monitorLogger.default.logNewSessionData({
      sessionState: _consts.SessionState.INITIALIZING,
      sessionId: session.data
    });

    _tasksLogger.default.run();

    executionStartTime = new Date().getTime();

    try {
      var sessionEndMessage = yield new Promise((resolve, reject) => {
        getSessionDataLoop(credentials, session.data, resolve, reject);
      });
      console.log(sessionEndMessage);
      process.exit(0);
    } catch (error) {
      var _error$response;

      console.log((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) ? error.response.data : error);
      process.exit(1);
    }
  });

  return function (_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

exports.default = _default;