"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _archiver = _interopRequireDefault(require("archiver"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _defaults = require("./common/defaults");

var _optionValidation = require("./common/option-validation");

var _utils = require("./common/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function _default(testsRoot) {
  var ignoreRegexList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var outPath = arguments.length > 2 ? arguments[2] : undefined;
  return new Promise((resolve, reject) => {
    (0, _optionValidation.validatePackOptions)(testsRoot, ignoreRegexList, outPath);
    var zipArchive = (0, _archiver.default)('zip', {});

    var zipFilePath = _path.default.resolve(outPath, _defaults.DEFAULT_ARCHIVE_FILE_NAME);

    if (!_fs.default.existsSync(_path.default.resolve(outPath))) {
      _fs.default.mkdirSync(_path.default.resolve(outPath), {
        recursive: true
      });
    }

    var output = _fs.default.createWriteStream(zipFilePath); // This event is fired when the data source is drained no matter what was the data source.
    // It is not part of this library but rather from the NodeJS Stream API.
    // @see: https://nodejs.org/api/stream.html#stream_event_end


    output.on('finish', function () {
      if (zipArchive.pointer() === 22) {
        reject(new Error('Zip archive contain zero files'));
      }

      console.log('Archive size:', zipArchive.pointer(), 'total bytes');
      console.log(zipFilePath);
      resolve(zipFilePath);
    }); // good practice to catch warnings (ie stat failures and other non-blocking errors)

    zipArchive.on('warning', function (err) {
      if (err.code === 'ENOENT') {
        console.warn(err);
      } else {
        reject(err);
      }
    }); // good practice to catch this error explicitly

    zipArchive.on('error', function (err) {
      reject(err);
    });
    zipArchive.on('entry', function (entry) {
      console.info(entry.name); // TODO: (Elhay) print only for log level verbose
    }); // pipe archive data to the file

    zipArchive.pipe(output);
    zipArchive.glob('**/+([!.]*|.npmrc)', {
      matchBase: true,
      cwd: testsRoot,
      dot: true,
      ignore: (0, _utils.getIgnoredFiles)(ignoreRegexList)
    });
    zipArchive.finalize();
  });
};

exports.default = _default;